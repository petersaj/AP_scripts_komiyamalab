function [classified_rois,classified_p] = AP_classify_movement_cells_continuous(data,analysis,split_time)
% [classified_rois,p] = AP_classify_movement_cells_continuous(data,analysis,split_time)
%
% Classify movement-related cells using
%
% Inputs: 
% data - from AP_corticospinal_load_all
% analysis - from AP_corticospinal_prepare_loaded
% split_time - can either be done on a session basis (no 3rd input), 
% or within a session split up into time blocks given by split_time
%
% Outputs:
% classified_rois - structure with logical vectors for movement or
% quiescent classifiation
% classified_p - p-value for classification ( > 0.975 = m, < 0.025 = q)

if nargin < 3
    
    classified_rois = struct('movement',cell(length(data),1),'quiescent',cell(length(data),1));
    classified_p = cell(length(data),1);
    
    for curr_animal = 1:length(data);
        
        n_rois = size(data(curr_animal).im(1).roi_trace_df,1);
        n_sessions = length(data(curr_animal).im);
        
        classified_rois(curr_animal).movement = false(n_rois,n_sessions);
        classified_rois(curr_animal).quiescent = false(n_rois,n_sessions);
        classified_p{curr_animal} = nan(n_rois,n_sessions);
        
        for curr_session = 1:n_sessions
                       
            activity_frames = +(data(curr_animal).im(curr_session).roi_trace_thresh > 0);
            
            lever_active_frames = analysis(curr_animal).lever(curr_session).lever_move_frames;
            
            % Split active frames by movement blocks / quiescent frames
            % (to split up by movement blocks / quiescent blocks)
            %lever_active_frames_nan = +lever_active_frames;
            %lever_active_frames_nan(~lever_active_frames) = NaN;
            boundary_frames = find(diff([Inf;lever_active_frames;Inf]) ~= 0);
            lever_active_frames_split = mat2cell(lever_active_frames,diff(boundary_frames));
                       
            % Get shuffled activity distribution
            num_rep = 10000;
            shuffle_perms = shake(repmat([1:length(lever_active_frames_split)]',1,num_rep),1);
            lever_active_shuffle = nan(length(lever_active_frames),num_rep);
            for i = 1:num_rep
                lever_active_shuffle(:,i) = ...
                    vertcat(lever_active_frames_split{shuffle_perms(:,i)});
            end
            clear shuffle_perms
            
            %%% Classify ROIs according to movement/quiescence preference
            movement_activity = activity_frames*lever_active_frames;           
            
            shuffle_movement_activity = activity_frames*lever_active_shuffle;
            clear lever_active_shuffle
            
            movement_rank = tiedrank([movement_activity shuffle_movement_activity]')';
            movement_p = movement_rank(:,1)/(num_rep+1);
            movement_cells = movement_p > 0.975;
            quiescent_cells = movement_p < 0.025;
            
            classified_rois(curr_animal).movement(:,curr_session) = movement_cells;
            classified_rois(curr_animal).quiescent(:,curr_session) = quiescent_cells;
            
            classified_p{curr_animal}(:,curr_session) = movement_p;
            
            % ROIs that are active but not movement/quiescent classified
            m = classified_rois(curr_animal).movement(:,curr_session);
            q = classified_rois(curr_animal).quiescent(:,curr_session);
            u = ~m & ~q;
            
            m_avg = nanmean(data(curr_animal).im(curr_session).roi_trace_thresh(m,:),2);
            q_avg = nanmean(data(curr_animal).im(curr_session).roi_trace_thresh(q,:),2);
            c_avg = nanmean(data(curr_animal).im(curr_session).roi_trace_thresh(m|q,:),2);
            u_avg = nanmean(data(curr_animal).im(curr_session).roi_trace_thresh(u,:),2);
            
            m_onsets = sum(diff(data(curr_animal).im(curr_session).roi_trace_thresh(m,:) > 0,[],2) == 1,2);
            q_onsets = sum(diff(data(curr_animal).im(curr_session).roi_trace_thresh(q,:) > 0,[],2) == 1,2);
            c_onsets = sum(diff(data(curr_animal).im(curr_session).roi_trace_thresh(m|q,:) > 0,[],2) == 1,2);
            u_onsets = sum(diff(data(curr_animal).im(curr_session).roi_trace_thresh(u,:) > 0,[],2) == 1,2);
            
            % Define "active unclassified"
            % 1) using minimum
            %u_active = u_avg > min(c_avg) & u_onsets > min(c_onsets);
            % 2) using percentile
            u_active = u_avg > prctile(c_avg,5) & u_onsets > prctile(c_onsets,5);

            classified_rois(curr_animal).unclassified_active(u,curr_session) = u_active;
                        
            
            disp(['Classified session ' num2str(curr_session)]);
        end
        
        disp(['Classified ' data(curr_animal).animal]);
    end
    disp('Finished all')
    
else
    
    classified_rois = struct('movement',cell(length(data),1),'quiescent',cell(length(data),1));
    classified_p = cell(length(data),1);
    
    for curr_animal = 1:length(data);
        
        n_rois = size(data(curr_animal).im(1).roi_trace_df,1);
        n_sessions = length(data(curr_animal).im);
        
        classified_rois(curr_animal).movement = cell(n_sessions);
        classified_rois(curr_animal).quiescent = cell(n_sessions);
        classified_p{curr_animal} = nan(n_rois,n_sessions);
        
        for curr_session = 1:n_sessions
            
            num_frames = size(data(curr_animal).im(curr_session).roi_trace_df,2);
            
            % Split frames into time bins, overlapping at end to keep time
            frames_split = linspace(0,:split_time:num_frames;
            
            for curr_split = 1:length(curr_frames);
                
                curr_act = +data(curr_animal).im(curr_session). ...
                    roi_trace_thresh(:,curr_frames{curr_split}) > 0;
                
                lever_active_frames = +analysis(curr_animal).lever(curr_session). ...
                    lever_move_frames(curr_frames{curr_split});
                
                % Split active frames by movement blocks / quiescent frames
                % (to split up by movement blocks / quiescent blocks)
                %lever_active_frames_nan = +lever_active_frames;
                %lever_active_frames_nan(~lever_active_frames) = NaN;
                boundary_frames = find(diff([Inf;lever_active_frames;Inf]) ~= 0);
                lever_active_frames_split = mat2cell(lever_active_frames,diff(boundary_frames));
                
                % Get activity during movement/quiescence
                movement_activity = curr_act*lever_active_frames;
                
                % Get shuffled activity distribution
                num_rep = 10000;
                shuffle_perms = shake(repmat([1:length(lever_active_frames_split)]',1,num_rep),1);
                lever_active_shuffle = nan(length(lever_active_frames),num_rep);
                for i = 1:num_rep
                    lever_active_shuffle(:,i) = ...
                        vertcat(lever_active_frames_split{shuffle_perms(:,i)});
                end
                clear shuffle_perms
                
                shuffle_movement_activity = curr_act*lever_active_shuffle;
                clear lever_active_shuffle
                
                movement_rank = tiedrank([movement_activity shuffle_movement_activity]')';
                movement_p = movement_rank(:,1)/(num_rep+1);
                movement_cells = movement_p > 0.975;
                quiescent_cells = movement_p < 0.025;
                
                classified_rois(curr_animal).movement{curr_session}(:,curr_split) = movement_cells;
                classified_rois(curr_animal).quiescent{curr_session}(:,curr_split) = quiescent_cells;
                
                classified_p{curr_animal}(:,curr_session) = movement_p;
                
            end
            
            disp(['Classified session ' num2str(curr_session)]);
        end
        
        disp(['Classified ' data(curr_animal).animal]);
    end
    disp('Finished all')
    
    
end




















